<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git操作指南]]></title>
    <url>%2F2019%2F08%2F16%2FGit%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[寻常操作查看此次修改内容：git diff查看提交日志：复杂版 ==&gt; git log; 简化版 ==&gt; git log –pretty=oneline 版本回退查找历史版本：git reflog.版本回退/前进：git reset –hard 版本ID.HEAD:当前版本. HEAD^:上一个版本 撤销修改丢弃工作区(未add)修改：git checkout – file.丢弃暂存区(未commit)修改：git reset HEAD file丢弃版本库（未push至远程库）修改：版本回退。 删除文件/文件恢复删除文件：git rm file文件恢复：git checkout – file(用版本库里的版本替换工作区的版本,注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！) 分支管理查看分支：git branch创建+切换分支：git checkout -b name（不加-b纯切换）合并某分支到当前分支：git merge name删除分支：git branch -d name 解决冲突将git合并失败的文件手动编辑为希望的内容，再提交.查看分支合并图：git log –graph –pretty=oneline 分支管理‘fast forward’模式，合并删除分支后，会丢掉分支信息，看不出做过合并:git merge name.‘–no-ff’模式，merge时会生成新的commit，能看出做过合并:git merge –no-ff -m commit text name Bug分支修复bug ==&gt; 创建bug分支进行修复，然后合并删除该分支存储工作现场：git stash恢复工作现场：git stash apply（恢复不删除stash）;git stash pop（恢复并删除stash） feature分支开发新feature,最好新建分支强行丢弃未合并的分支：git branch -D name 团队开发1.git push origin branch-name 推送自己的修改；2.如果推送失败，则远程分支比你的本地更新，用git pull试图合并；3.如果合并有冲突，手动解决冲突，并在本地提交；4.冲突解决后，git push origin branch-name推送就能成功！（注意：如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to branch-name origin/branch-name） Rebase 干净、线性的提交历史，没有不必要的合并提交 ==&gt; git rebase 保存项目完整的历史，避免重写公共分支上的commit ==&gt; git merge 切到本地分支：git checkout local交互式rebase：git rebase -i HEAD~2 //合并两个普通rebase：git rebase master –&gt; 解决冲突 –&gt; git rebase –continue 标签管理新建标签：git tag tagname, 默认在HEAD新建，也可指定commit id指定标签信息：git tag -a tagname -m blablabla...查看所有标签：git tag推送本地标签：git push origin tagname推送全部未推送过的本地标签：git push origin –tags删除本地标签：git tag -d tagname删除远程标签：先本地删，后git push origin :refs/tags/tagname 自定义Git忽略某些文件：.gitignore忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 配置命令简写：git config –global alias.co checkout 仓库Git配置文件都放在.git/config文件中用户Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TechShare]]></title>
    <url>%2F2019%2F08%2F16%2FTechShare%2F</url>
    <content type="text"><![CDATA[域名解析过程例如要寻找主机名为ice.cube.com，且DNS客户端为CentOS系统1.主机查找本地的/etc/hosts文件，如果有对应的记录，直接可以访问。如果没有则到下一步2.向本地的DNS服务器发起请求本地的DNS服务查找自己的记录，看能否找到请求的IP地址如果有这个地址，则返回地址给主机，如果不能则到下一步3.发起迭代请求，首先向根服务器发起请求4.根服务器发现无法给出ice.cube.com的地址，但是它能提供顶级域.com的地址，于是返回.com的地址5.于是本地DNS服务器发送请求给.com名称服务器。询问ice.cube.com的IP地址6.com名称服务器发现无法给出具体地址，但是知道cube.com的地址，于是.com返回.cube.com的地址。7.本地DNS服务器向.cube.com发起请求。8.当.cuce.com查看请求域名为ice.cube.com，查找记录，得到地址。然后返回本地DNS服务器地址。9.本地DNS服务器缓存该地址并返回给主机10.主机得到ice.cube.com对应的IP于是可以正常通信 git配置多个ssh问题1ssh-keygen -t rsa -C &apos;yourEmail@xx.com&apos; -f ~/.ssh/gitlab-rsa 生成ssh密钥时区分取名 ~/.ssh/config文件下配置不同host使用的不同ssh key 配置文件参数1234# Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件# HostName : 要登录主机的主机名# User : 登录名# IdentityFile : 指明上面User对应的identityFile路径 使用命令将其添加到SSH agent,命令如下： 12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_github 客户端与浏览器交互： 客户端请求建立SSL连接，将加密规则发送给网站。 网站选出一组加密算法与HASH算法，并将身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息 获得网站证书之后浏览器要做以下工作: 验证证书的合法性；如果证书受信任，浏览器会生成一串随机密码，并用证书中提供的公钥加密；使用约定好的HASH计算握手消息；使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 网站接收浏览器发来的数据之后要做以下的操作： 使用自己的私钥将信息解密取出密码；使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致；使用密码加密一段握手消息，发送给浏览器 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手结束。 使用随机密码和对称加密算法对传输的数据加密，传输。 测试Unit Test 单元测试在最低的功能/参数上验证程序的准确性,比如测试一个函数的正确性(开发人员做的)Integration Test 集成测试假定各个软件单元已通过单元测试，检查各个软件单元接口之间的协同工作是否正确Stress test 压力测试测试在一定的负载下系统长时间运行的稳定性，尤其关注大业务量情况下长时间运行系统性能的变化（例如是否反应变慢、是否会内存泄漏导致系统逐渐崩溃、是否能恢复）Performance test 性能测试表示在一个给定的基准下，能执行的最好情况。Smoke Test 冒烟测试“冒烟”–如果测试不通过，则不能进行下一步工作Regression Test 回归测试修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误的一种测试方法。契约测试也叫消费者驱动测试，Consumer 端提供一个类似“契约”的东西（如json 文件，约定好request和response）交给Provider 端，告诉Provider 有什么需求，然后Provider 根据这份“契约”去实现。UI测试测试用户界面的风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等E2E将程序模拟为黑盒，不care内部实现，只care浏览器上的交互效果是不是我要的。 金字塔：压力 性能 冒烟 UI e2e 契约 集成 回归 单元]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Week5]]></title>
    <url>%2F2019%2F08%2F16%2FWeek5%2F</url>
    <content type="text"><![CDATA[Github连接不上：ping www.baidu.com //网络连接正常ping github.com //请求超时 ===&gt; 怀疑DNS无法解析 解决方案：手动查找可用的DNS域名：站长之家查询-选择TTL值最低的DNS域名 打开hosts文件 1sudo subl /etc/hosts 替换github dns域名 React Practicegitlab –&gt; WebpackBebel-ReactDemo props与state的区别：props是组件间传递的一种方式，props也可以传递state。由于React的数据流是自上而下的，所以是从父组件向子组件进行传递；组件内部的this.props是只读属性！state是组件内部的状态(数据),不能够直接修改，必须要通过setState来改变值的状态，从而达到更新组件内部数据的作用。属于state的有：用户输入的搜索词、复选框是否选中的值。props是传递给组件的(类似于函数的形参)，而state是在组件内被组件自己管理的(类似于在一个函数内声明的变量)。 props和state是经常要结合使用的，父组件的state可以转化为props来为子组件传值。 css 文件无法引入考虑webpack打包问题npm install –save-dev css-loader style-loaderwebpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;], &#125;, ], &#125;,&#125;; file.js 1import &apos;./file.css&apos;; TDD 测试驱动开发Given my bank account is in credit, and I made no withdrawals recently,When I attempt to withdraw an amount less than my card’s limit,Then the withdrawal should complete without errors or warnings 实践步骤： 根据需求拆分Task 根据每一项Task写对应test 基于让test通过的原则编写实现代码，不做多余操作 ##TDD practicehttps://github.com/Emma0s/TDD-parking]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Week4]]></title>
    <url>%2F2019%2F08%2F16%2FWeek4%2F</url>
    <content type="text"><![CDATA[React practicegitlab–&gt;WebpackBebel-ReactDemo OAuth2 再识 用户访问客户端，客户端将用户导向认证服务器 用户选择是否给予客户端授权 假设用户给予授权，认证服务器将用户导向客户端事先指定的重定向URI，同时附上一个授权码 客户端收到授权码，附上早先的重定向URI，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）等 第一步：客户端申请认证的URI=&gt; https://facebook.com/dialog/oauth?response_type=code&amp;client_id=YOUR_CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=email response_type：表示授权类型，必选项，此处的值固定为”code”client_id：表示客户端的ID，必选项。redirect_uri：表示重定向URI，可选项scope：表示申请的权限范围，可选项state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值 第三步：服务器将用户导向URI，同时附上授权码 =&gt; HTTP/1.1 302 FoundLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID、重定向URI一一对应。state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 第四步：客户端向认证服务器申请令牌 grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。code：表示上一步获得的授权码，必选项。redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 1234567POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb 第五步：认证服务器发送的HTTP回复Oauth_Server返回token，这个时候，就可以通过token获取用户授权的资源了。access_token：表示访问令牌，必选项。token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 1234567891011HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache &#123; &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;, &quot;token_type&quot;:&quot;example&quot;, &quot;expires_in&quot;:3600, &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;, &quot;example_parameter&quot;:&quot;example_value&quot; &#125; Refresh token如果用户访问的时候，客户端的访问令牌access_token已经过期，则需要使用更新令牌refresh_token申请一个新的访问令牌。 客户端发出更新令牌的HTTP请求，包含以下参数：grant_type：表示使用的授权模式，此处的值固定为”refresh_token”，必选项。refresh_token：表示早前收到的更新令牌，必选项。scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA semver 语义化版本规范 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号：发布正式版之前的版本，如：alpha：是内部测试版,一般不向外部发布,会有很多Bug，一般只有测试人员使用。 如：1.0​​.0-alphabeta：也是测试版，这个阶段的版本会一直加入新的功能，在Alpha版之后推出rc：(Release Candidate) 系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。 定义依赖版本号：^ ：表示同一主版本号中，不小于指定版本号的版本号^2.2.1 ==&gt; 2.2.1、2.2.2、2.3.0 ,主版本号固定 ~ ：表示同一主版本号和次版本号中，不小于指定版本号的版本号~2.2.1 ==&gt; 2.2.1、2.2.2，主版本号和次版本号固定 &lt;、&gt;、=、&gt;=、&lt;=、-：用来指定一个版本号范围 &gt;2.1 1.0.0 - 1.2.0 ||：表示或 x、X、*：表示通配符 3.x ==&gt; 所有主版本号为 3 的版本号]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Week3]]></title>
    <url>%2F2019%2F08%2F16%2FWeek3%2F</url>
    <content type="text"><![CDATA[MVC(Model-View-Controller)视图（View）：用户界面控制器（controller）：业务逻辑模型（Model）： 数据保存单向通信：也就是View与Model，必须通过Controller来承上启下。MVP、MVVM源于MVC MVP 各部分之间的通信， 都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为被动视图，Presenter 非常厚，所有逻辑都部署在那里。 MVVM双向数据绑定，(data-binding) ：模型 =&gt; 视图，将后端传递的数据转化成所看到的页面(数据绑定)视图 =&gt; 模型，将所看到的页面转化成后端的数据(DOM 事件监听) Why MVVM前端逐渐臃肿，仅靠controller完成前后端交互，工作量太大，响应速度也变慢。引出mvvm模式解决mvc中大量DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的问题。View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Locke Radarmjml: 简洁易开发的标记语言，帮助编写响应式电子邮件BigQuery: Google的低成本分析数据仓库，内置内存BI引擎和机器学习，无需数据库管理员kasada: 用于企业web应用程序的Bot检测，识别真实用户与机器访问。 Webpack+Babel+React完整配置 12345678910npm init npm i --save react react-dom // react相关依赖包npm i --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-react //webpack依赖包npm i --save-dev webpack webpack-cli webpack-dev-server //babel相关依赖包,把jsx转成js可识别的函数npm i --save-dev html-webpack-plugin //安装复制文件插件npm i --save-dev style-loader css-loader postcss-loader sass-loader //识别sass、cssnpm i --save-dev file-laoder //识别文件npm i --save-dev svg-inline-loader //识别svg图像npm i --save-dev react-hot-loader //热更新 others:npm i module_name -S = &gt; npm install module_name –save 写入到 dependencies 对象(需要发布到生产环境)npm i module_name -D =&gt; npm install module_name –save-dev 写入到 devDependencies 对象(只用于开发环境) 12345&lt;package.json&gt; &quot;scripts&quot;: &#123; //定义脚本命令 &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config config/webpack.config.dev.js&quot; //npm run dev即可运行开发服务器模式 &#125;, 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;webpack.config.js&gt;const path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const resolve = (dir) =&gt; path.join(__dirname, &apos;../&apos;, dir)module.exports = &#123; mode: &apos;development&apos;, devtool: &apos;cheap-module-eval-source-map&apos;, entry: &#123; //入口文件 app: resolve(&apos;src/index.jsx&apos;) &#125;, output: &#123; filename: &apos;[name].js&apos;, path: resolve(&apos;dist&apos;) &#125;, resolve: &#123; //指定可以被 import 的文件后缀 extensions: [&apos;.js&apos;, &apos;.jsx&apos;, &apos;.scss&apos;, &apos;.css&apos;] &#125;, module: &#123; //通过正则表达式去匹配不同后缀的文件名，然后给它们定义不同的加载器 rules: [ &#123; test: /\.(js|jsx)$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, options: &#123; plugins: [&apos;react-hot-loader/babel&apos;], presets: [&apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos;] //babel插件集合的预设 &#125;, &#125;, ... //其他rules ]&#125;, devServer: &#123; host: &apos;localhost&apos;, port: &apos;8001&apos;, open: true &#125;, plugins: [ //使用插件，先require()它，然后把它添加到 plugins 数组中。 new HtmlWebpackPlugin(&#123; filename: resolve(&apos;dist/index.html&apos;), template: resolve(&quot;static/index.html&quot;) &#125;) ]&#125; 12345678&lt;react入口文件&gt;import ReactDOM from &apos;react-dom&apos;import React from &apos;react&apos;ReactDOM.render( &lt;h1&gt;hello webpack&lt;/h1&gt;, document.getElementById(&apos;root&apos;)) migration输入：用户名、密码输出：将老用户的用户名及密码从DB1迁到DB2 用户登陆 在DB1中验证是否为已有用户，若用户已存在 =&gt; 3，若为新用户 =&gt; 4 验证用户名密码是否正确 拿到用户名及明文密码采用DB2的算法存入DB2 ReactWhy JSX We strongly believe that components are the right way to separate concerns rather than “templates” and “display logic.” —React官方 若以组件为中心，把 HTML 模板直接嵌入到 JS 代码里面，这样就做到了模板和组件关联。==&gt; JSX JSX use：HTML 里的 class 在 JSX 里要写成 className，因为 class 在 JS 里是保留关键字。同理某些属性比如 for 要写成 htmlFor。 ReactDOM.render(template,targetDOM),将模板转化为HTML语言，并插入指定的DOM节点。接收两个参数：第一个是创建的模板，多个dom元素外层需使用一个标签进行包裹；第二个参数是插入该模板的目标位置。]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Week2]]></title>
    <url>%2F2019%2F08%2F16%2FWeek2%2F</url>
    <content type="text"><![CDATA[TS demo： 通过map、filter实例理解函数式编程 学会用yarn指令运行jest测试代码 使用命令行代码将更新push到gitlab上 Used in AWS：Lambda: 无服务器计算服务S3：对象存储服务DynamoDB：键/值和文档数据库–&gt;NoSQL 数据库服务CloudFront：内容分发服务，依靠edge location，使客户最小延迟的拿到数据Route 53：云[域名系统 (DNS)]Web 服务（云是一种按量付费的计算机资源共享池）API Gateway：构建、部署、管理APICloudWatch：监控资源及应用程序CloudFormation：使用模版创建并管理资源Kinesis：分析实时视频和数据流IAM：管理用户访问及密钥Cognito：userpool / identity poolCertificate Manager：预置、管理和部署 (SSL/TLS) 证书 Jest： know some matchers –&gt; Truthiness/Numbers/Strings/Arrays/Exceptions mock函数：jest.fn()测试回调函数；jest.mock()测试整个模块中的方法；jest.spyOn()测试必须被完整执行的方法 CronJob：在固定时间运行的Job对象 测试金字塔：UI –》Service –》Unit慢 ——————— 快 测试原则： 只关注输入输出，不关注内部实现 只测一条分支（即一个业务场景，有针对性） 表达力极强（描述强，数据简练，报告详细） 不包含逻辑（避免测试本身出错） 运行速度快（尽可能地避免依赖：mock隔离三方依赖（如数据库、网络、文件等）） 技术总结：理清楚文章的思路和概要 —&gt; 论文（不是拼凑，重点表达中心思想）结构要清晰，上下文紧密时布局紧密，上下文分离时布局分离段落有重点，整体有重点代码、概念引用：core，简洁明了细节：排版，错别字]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Week1]]></title>
    <url>%2F2019%2F08%2F16%2FWeek1%2F</url>
    <content type="text"><![CDATA[git基本操作初始化 创建新版本库git clone 项目地址 (克隆一份到本地)cd 项目本机地址touch README.md (创建文件)git add ./README.md (添加资料到本地缓存区、可反复多次使用，添加多个文件)git commit -m”备注 上传什么东西” （添加所有资料到本地库）git push -u origin master (将本地库push到服务器上面的msater) othersgit branch -a （查看所有本地分支)git checkout -b dev(创建并切换到dev分支，已有该分支就不加-b)git merge self (将self分支合并到dev上,此步骤需切换至主分支)git push –delete origin 远程分支名（删除远程分支）git status(即gst) 检查本地需要提交的文件 备份修改git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作)git stash pop(恢复备份的工作现场）tig 查看本地日志 查看精简日志：git log –pretty=oneline 暂存区概念： 代码库更新git fetch 拉取最新工程git rebase master 与本地分支合并（提交更改前他人抢先提交代码时用） 查看修改内容：git diff 版本回退：git reset –hard commit_id。HEAD指向的版本就是当前版本，上一个版本就是HEAD^回退前，用git log可以查看提交历史，以便查找回退版本的ID。重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 pull冲突终端：拉取pull -&gt; 解决冲突 -&gt; 正常提交 覆盖修改（本地提交3次通过覆盖远程端提交2次）前两次正常commit、push -&gt; 第三次修改后（git commit –amend 、git push -f origin B) CI/CDWhat CI：将应用代码的新更改定期构建、测试并合并到共享存储库中（有需人工操作的按钮）CD：自动将应用发布到生产环境（无按钮） How通过buildkit工具：配置pipeline.yml文件，由auto参数指定操作 Why缩短产品上市时间，降低实施成本，提高监控能力。传统部署方式可移植性差，对存储能力要求高，代码更新后，甚至需要重启部署。（典型如tomcat、img镜像备份方式） Application实际应用时，由于buildkit方式通常需要先测试后部署，若修改较大且有短时响应需求时，可暂时采用CI，先完成测试，时机合适时人工操作开始部署。 AWS Cognito userpool：为应用程序提供注册和登录选项的用户目录。 identity：提供 AWS 凭证以向用户授予对其他 AWS 服务的访问权限。 Application实际应用时，其他业务线进入网站做某些操作时，要进本线userpool完成用户认证。 otherspool ARN ：地区+account+user pool+identity poolLambda：“一段程序”S3：simple storage service 尾递归尾递归 = 尾调用 + 递归 递归：函数调用自身，称为递归 尾调用：函数最后是调用另一个函数 总结：一个函数在其内部最后一步调用其自身 12return tailrec(x+1); //尾递归 return tailrec(x+1) + x; //非尾递归 OAuth2 + OpenID1.0OAuth角色: Consumer：消费方 Service Provider：服务提供者 User：用户 OAuth流程：（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源。 OAuth和OpenID的区别：OAuth关注的是authorization授权，即：“用户能做什么”；而OpenID侧重的是authentication认证，即：“用户是谁”。前者是网站对用户进行认证，让网站知道“你是你所声称的URL的属主”后者其实并不包括认证，只不过“只有认证成功的人才能进行授权”，结果类似于“认证+授权”]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript相关]]></title>
    <url>%2F2019%2F08%2F16%2FTypeScript%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[What TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。TypeScript 是由微软开发的自由和开源的编程语言。TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。 install推荐VS Code ，atom 需要安装 atom-typescript包，sublime需要安装Typescript-sublime-plugin。 全局安装：npm install typescript -g 创建.ts结尾的文件 在命令行中执行tsc+项目文件名,这个命令可以将我们写好的ts代码编写成JavaScript代码,并且进行数据类型检查（如tsc hello.ts） 变量声明var [变量名] : [类型] = 值; 1var uname:string = &quot;Runoob&quot;; 基础类型 字符串与JavaScript一样,可以使用双引号(“”)和单引号(‘’)表示字符串let name: string = ‘jack’name = “lili”还可以使用模板字符串let hello = hello my name is ${name} 元组元组类型允许表示一个已知元素数量和类型的数组,各元素的类型不必相同. 123let arr: [string, number]arr = [&apos;li&apos;, 5] //对arr = [5, &apos;li&apos;] //错 枚举枚举是一个可被命名的整型常数的集合，枚举类型为集合成员赋予有意义的名称，增强可读性 123enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Blue;console.log(c); // 输出 2 枚举默认下标是0，可以手动修改默认下标值 123enum Color &#123;Red = 2, Blue, Green = 6&#125;;let c: Color = Color.Blue;console.log(c); // 输出：3 任意值any不清楚变量类型,并且希望在编译的时候不进行检查.使用any任意类型来标记这些变量 12let anyVariable:any = 4anyVariable = &apos;hello&apos; Never表示那些永不存在的值的类型。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。 123456789101112// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; Object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 123456declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(&quot;string&quot;); // Errorcreate(undefined); // Error 类型断言类型断言有两种形式。 其一是“尖括号”语法,另一个为as语法： 12345let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 接口TS 里接口可以描述变量、函数类型和类类型，其它语言只能描述类类型。接口描述变量时可以使用’?’定义某个变量为可选变量。比如对某个对象进行约束时，如果对象的某个属性设置成了可选，则传入的对象可以不包含这个属性。 12345678910111213interface LabelledValue &#123; size?: Number, label: String&#125;function printLabel(labelObject: LabelledValue) &#123; return labelObject.label;&#125;// 由于size设置成了可选变量，则传入的对象可以不包含size属性console.log(printLabel(&#123; label: &apos;size 1 object&apos;&#125;)); 接口 - 描述函数类型12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 接口 - 描述类类型不同于别的语言只能定义函数，TS里还可以定义属性。如果某个类继承了这个接口，那么这个类必须包含接口里定义的属性和方法。 1234567891011interface ClockInterface &#123; currentTime: Date; setTime(d: Date): any;&#125;class Clock implements ClockInterface &#123; currentTime = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 装饰器Decorator是一个函数，用来修饰类、属性、方法和参数。使用 @expression 。 12345function color(value: string) &#123; // 这是一个装饰器工厂 return function (target) &#123; // 这是装饰器 // do something with &quot;target&quot; and &quot;value&quot;... &#125;&#125; 类装饰器@func 修饰 类A 等价于 A = func(A)，相当于把旧class转换成了新的class。可以理解为一个加工函数，它接受一个类，加工后返回另一个类。 12345678910111213141516//使用类装饰器(@sealed)的例子，应用在Greeter类：@sealedclass Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;//定义@sealed装饰器：function sealed(constructor: Function) &#123; Object.seal(constructor); Object.seal(constructor.prototype);&#125; 方法装饰器123456789101112131415161718//方法装饰器（@enumerable），应用于Greeter类的方法上：class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; @enumerable(false) greet() &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;//可以用下面的函数声明来定义@enumerable装饰器：function enumerable(value: boolean) &#123; return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; descriptor.enumerable = value; &#125;;&#125;]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶]]></title>
    <url>%2F2019%2F08%2F16%2FJavaScript%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[执行环境 执行环境(execution context)定义了变量或者函数有权访问的其他数据，每个执行环境都有一个与之关联的变量对象(variable object)，执行环境中定义的变量和函数就保存在这个变量对象中；全局执行环境是最外围的一个执行环境，通常被认为是window对象执行环境和变量对象在运行函数时生成执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁) 声明提前123456var scope =&quot;global&quot;;function f() &#123; console.log(scope); //输出&quot;undefined&quot; var scope = &quot;local&quot;; //变量在此赋初值，但变量本身在函数体内任何地方都是有定义的 console.log(scope); //输出&quot;local&quot;&#125; 即将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原位置。 作用域链 当代码在一个执行环境中执行时，会创建变量对象的一个作用域链(scope chain)，作用域链用来指定执行环境有权访问的所有变量和函数的访问顺序；作用域链的最前端，始终是当前代码执行环境的变量对象，如果这个环境是函数，则其活动对象就是变量对象作用域链的下一个变量对象，来自外部包含环境，再下一个变量对象，来自下一个外部包含环境，以此类推直到全局执行环境在函数执行过程，根据当前执行环境的作用域链来逐层向外查找变量，并且进行标识符解析 闭包 闭包是指有权访问另一个函数作用域变量的函数，创建闭包的通常方式，是在一个函数内部创建另一个函数，闭包的本质还是函数 123456789101112131415&lt;script&gt; function A()&#123; var funs=[]; for(var i=0;i&lt;10;i++)&#123; funs[i]=function()&#123; return i; &#125; &#125; return funs; &#125; var funs = A();//定义funs[0]-funs[9]，10个函数 funs[0](); //10 funs[1](); //10 funs[6](); //10&lt;/script&gt; 以上代码创建了10个闭包，并存储于同一个数组中。这些闭包都是在同一个函数调用中定义的，因此可以共享变量i。 1234567891011121314151617 &lt;script&gt; function A()&#123; var funs=[]; for(var i=0;i&lt;10;i++)&#123; funs[i] = (function anonymous1(num)&#123; return function anonymous2()&#123; return num; &#125; &#125;(i)); &#125; return funs; &#125; var funs = A();//定义funs[0]-funs[9]，10个函数 funs[0](); //0 funs[1](); //1 funs[6](); //6&lt;/script&gt; function anonymous1(num){}(i)，这是一个立即执行函数。即( function(){…} )()和( function (){…} () )，立即执行函数把i的值立即传递给num这个局部变量，然后再返回anonymous2，存贮的num值就是每次传入的i值，也就是0-9。 Promise特点：（1）对象的状态不受外界影响。有三种状态：pending（初始状态）、fulfilled（操作成功）、rejected（操作失败）（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。状态改变只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。 优点：可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。缺点：首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法12345678910new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;hello resolve&apos;); &#125;, 500);&#125;).then(val =&gt; &#123; console.log(val);// hello resolve&#125;, err =&gt; &#123; console.error(err);// 该条语句不被执行&#125;); resolve 函数的作用：将 Promise 对象的状态从“未完成（pending）”变为“成功（resolved）”，在异步操作成功时调用，并将异步操作的结果作为参数传递出去。 reject 函数的作用：将 Promise 对象的状态从“未完成（pending）”变为“失败（rejected）”在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 then 方法作用：接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。第二个函数可选，不一定要提供，也可以将第二个函数作为 catch 方法的参数。 catch 方法作用：用于指定发生错误时的回调函数。Promise 对象异步操作抛出错误，状态就会变为 rejected，就会调用 catch 方法指定的回调函数处理这个错误。另外，then 方法指定的回调函数，如果运行中抛出错误，也会被 catch 方法捕获。 Promise执行顺序12345678910const promise = new Promise((resolve, reject) =&gt; &#123; console.log(&quot;我是第一个执行的&quot;); //Promise 新建后立即执行 resolve();&#125;);promise.then(res =&gt; &#123; console.log(&quot;我是第三个执行的&quot;); //then 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行,同catch&#125;);console.log(&quot;我是第二个执行的&quot;) Promise链式调用then 方法可以返回一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。只要一个 Promise 中抛出错误，将执行 catch 方法，then 链终止 Promise.prototype.finally()finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。本质上是 then 方法的特例，不接受任何参数，不依赖于 Promise 的执行结果 Promise.all()用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const promise = Promise.all([promise1, promise2, promise3]) Promise.all 方法接受一个数组作为参数，promise、promise2、promise3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。 promise 的状态由 promise1、promise2、promise3 决定，分成两种情况: 三者状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 promise1、promise2、promise3 的返回值组成一个数组，传递给 p 的回调函数。 三者中有一个被 rejected，promise 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 promise 的回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;hello&quot;);&#125;) .then(result =&gt; result) .catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&quot;报错了&quot;);&#125;) .then(result =&gt; result) .catch(e =&gt; e);Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] 上面代码中，p1 会 resolved，p2 首先会 rejected，但是 p2 有自己的 catch 方法，该方法返回的是一个新的 Promise 实例，p2 指向的实际上是这个实例。该实例执行完 catch 方法后，也会变成 resolved，导致 Promise.all()方法参数里面的两个实例都会 resolved，因此会调用 then 方法指定的回调函数，而不会调用 catch 方法指定的回调函数。 如果 p2 没有自己的 catch 方法，就会调用 Promise.all()的 catch 方法。 Promise.race()同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]) 只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。 Promise.resolve()将现有对象转化为 Promise 对象。 1const promise = Promise.resolve(&apos;Hello world&apos;) 参数是 Promise 实例，该方法不做任何改变。 参数是一个 thenable 对象，先将对象转为 Promise 对象，然后立即执行 thenable 方法。相当于将 thenable 对象中的 then 方法处理的值作为参数传给 promise then 方法。 参数不是具有 then 方法的对象，或根本就不是对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。 JS异步JS只能是单线程，但任务可以被设计为同步任务和异步任务。 EVENT LOOP（事件循环） 同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。 系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列的末端，每个任务会对应一个回调函数进行处理。 执行任务队列中的任务具体是在执行栈中完成的，全部执行完毕后，去读取任务队列中的下一个任务，继续执行，是一个循环的过程，处理一个队列中的任务称之为tick。 更详细的流程图： 定时器 setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 1setInterval(code,millisec,lang) //lang为可选参数 setTimeout() ：在指定的毫秒数后调用函数或计算表达式 1setTimeout(code,millisec,lang) //lang为可选参数 错误处理使用 try/catch 进行错误处理。在 Promise 中的 .catch() 分支会进入 catch 语句。 四种异步实现方案1.回调函数1234567function f1(callback)&#123; setTimeout(function()&#123; //f1的代码 callback(); &#125;,1000)&#125;f1(f2); 思想：把同步操作变成异步，相当于先执行程序的主要逻辑并将耗时的延迟执行优点：简单明了；缺点：①、耦合严重；②、容易陷入回调地狱 2.事件监听常见的监听函数有：on，bind，listen、addEventListener，observe 1234567f1.on(&quot;done&quot;.f2); //f1执行完成后立即触发done事件从而执行f2function f1()&#123; setTimeout(function()&#123; //f1的代码量 f1.trigger(&quot;done&quot;); // 执行完函数体部分 触发done事件 &#125;,1000)&#125; 优点：避免了直接使用回调的高耦合问题，可以绑定多个回调函数缺点：变成了事件驱动模型，不易看出执行的主流程 3.发布/订阅模式123456789jQuery.subscribe(&quot;done&quot;,f2); //f2向&quot;信号中心&quot;jQuery订阅&quot;done&quot;信号。function f1()&#123; setTimeout(function()&#123; //f1的代码 jQuery.publish(&quot;done&quot;); //f1执行完成后，向&quot;信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。 &#125;,1000)&#125;jQuery.unsubscribe(&quot;done&quot;, f2); //f2完成执行后，可以取消订阅（unsubscribe） 事件监听模式中，被监听函数f1与监听函数f2直接交流 发布/订阅模式中，发布者f1和消息中心交流，订阅者f2也和消息中心交流 4.Promises对象每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数 1f1().then(f2).then(f3); Async/AwaitAsync - 定义异步函数(async function someName(){...}) 自动把函数转换为 Promise 当调用异步函数时，函数返回值会被 resolve 处理 异步函数内部可以使用 await Await - 暂停异步函数的执行 (var result = await someAsyncCall();) 当使用在 Promise 前面时，await 等待 Promise 完成，并返回 Promise 的结果 await 只能和 Promise 一起使用，不能和 callback 一起使用 await 只能用在 async 函数中 与Promise关系 Async/Await 底层依然使用了 Promise。 多个异步函数同时执行时，需要借助 Promise.all每次遇到 await 关键字时，Promise 都会停下在，一直到运行结束，await 把异步变成了同步。 123456789101112131415161718async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt();// c:\var\test&gt;node --harmony_async_await .// step1 with 300// step2 with 800 = 300 + 500// step3 with 1800 = 300 + 500 + 1000// result is 2000// doIt: 2907.387ms]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F08%2F15%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS使用内部引用：在 HTML 中，JavaScript 代码必须位于 与 标签之间。 外部引用：将.js文件通过src属性导入 1&lt;script src=&quot;/js/myScript1.js&quot;&gt;&lt;/script&gt; JS显示 window.alert() 写入警告框document.write() 写入 HTML 输出innerHTML 写入 HTML 元素console.log() 写入浏览器控制台 JS运算取幂运算符：x ** y 产生的结果与 Math.pow(x,y) 相同: JS数据类型Undefined与Null区别：Undefined 与 null 的值相等，但类型不相等：1234typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true typeof运算符对简单数据返回： string number boolean undefined 对复杂数据返回： function object JS事件 事件 描述 onchange HTML 元素已被改变 onclick 用户点击了 HTML 元素 onmouseover 用户把鼠标移动到 HTML 元素上 onmouseout 用户把鼠标移开 HTML 元素 onkeydown 用户按下键盘按键 onload 浏览器已经完成页面加载 JS字符串方法indexOf()方法返回字符串中指定文本首次出现的索引（位置）lastIndexOf()方法返回指定文本在字符串中最后一次出现的索引search()方法搜索特定值的字符串，并返回匹配的位置区别：search() 方法无法设置第二个开始位置参数。indexOf() 方法无法设置更强大的搜索值（正则表达式） 12345slice(start, end) //提取字符串substring(start, end) //无法接受负的索引 substr(start, length) //类似于slice() var text = &quot;Hello&quot;.concat(&quot; &quot;,&quot;World!&quot;); //concat() 连接两个或多个字符串： text.split(&quot;,&quot;); // 用逗号分隔,将字符串转换为数组 JS数字NAN：指示某个数不是合法数。12var x = 100 / &quot;Apple&quot;; // x 将是 NaN（Not a Number）var x = 100 / &quot;10&quot;; // x 将是 10 isNaN()确定某个值是否是数： InfinityInfinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值。 12345while (myNumber != Infinity) &#123; // 执行直到 Infinity myNumber = myNumber * myNumber; myNumber.toString(8); // 返回8进制的myNumber&#125;var x = 2 / 0; // x 将是 Infinity toExponential() 方法toExponential() 返回字符串值，包含已被四舍五入并使用指数计数法的数字，参数为小数点后的字符数 123var x = 9.656;x.toExponential(2); // 返回 9.66e+0x.toExponential(4); // 返回 9.6560e+0 toFixed() 方法toFixed() 返回字符串值，指定小数的位数： 12x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560 toPrecision() 方法toPrecision() 返回字符串值，包含指定长度的数字 1x.toPrecision(4); // 返回 9.656 JavaScript 数组方法join() 方法：将所有数组元素结合为一个字符串 12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;];document.getElementById(&quot;demo&quot;).innerHTML = fruits.join(&quot; * &quot;); //结果为Banana * Orange * Apple * Mango shift() 方法：删除数组的第一个元素（并将所有其他元素“移位”到左侧）unshift() 方法：将新元素添加到数组的开头splice() 方法：用于向数组添加新项：第一个参数（2）定义了应添加新元素的位置（拼接），第二个参数（0）定义应删除多少元素，其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。删除元素：第一个参数（0）定义新元素应该被添加（接入）的位置，第二个参数（1）定义应该删除多个元素。 1234var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); //结果为Banana,Orange,Lemon,Kiwi,Apple,Mangofruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;); //结果为Banana,Orange,Apple,Mangofruits.splice(0, 1); // 删除 fruits 中的第一个元素 slice() 方法：用数组的某个片段切出新数组。 123var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(3); //Apple,Mangovar citrus = fruits.slice(1, 3); //Orange,Lemon 数组排序sort() 函数按照字符串顺序对值进行排序（”Apple” 会排在 “Banana” 之前； “25” 大于 “100”） 比值函数：定义一种排序顺序比较函数应该返回一个负，零或正值，这取决于参数： function(a, b){return a-b} 当 sort() 函数比较两个值时，会将值发送到比较函数，并根据所返回的值（负、零或正值）对这些值进行排序。 1points.sort(function(a, b)&#123;return a - b&#125;); //function(40,100)，计算 40-100，然后返回 -60（负值）。排序函数将把 40 排序为比 100 更低的值。 Math.max.apply([1, 2, 3]) 等于 Math.max(1, 2, 3)，即查找数组中的最高值：Math.min.apply([1, 2, 3]) 等于 Math.min(1, 2, 3)，即查找数组中的最高值： 数组迭代Array.forEach()：为每个数组元素调用一次函数（回调函数）。Array.map()：方法通过对每个数组元素执行函数来创建新数组。（不会对没有值的数组元素执行函数；不会更改原始数组）Array.filter()：创建一个包含通过测试的数组元素的新数组。Array.every()：检查所有数组值是否通过测试。Array.some()：检查某些数组值是否通过了测试。（返回boolean）Array.find()：返回通过测试函数的第一个数组元素的值。Array.findIndex()：返回通过测试函数的第一个数组元素的索引。——-function myFunction(value, index, array) {}Array.reduce()：在每个数组元素上运行函数，以生成（减少它）单个值。Array.reduceRight()方法在每个数组元素上运行函数，以生成（减少它）单个值。——-function myFunction(total, value, index, array) {} 123456789101112131415var txt = &quot;&quot;;var numbers = [45, 4, 9, 16, 25];var numbers1 = numbers.forEach(myFunction);var numbers2 = numbers.map(myFunction);var over18 = numbers.filter(myFunction);function myFunction(value) &#123; txt = txt + value + &quot;&lt;br&gt;&quot;; &#125;function myFunction(value, index, array) &#123; return value * 2; //90,8,18,32,50&#125;function myFunction(value) &#123; return value &gt; 18; //45,25&#125; Hoisting：在顶部声明变量！Use Strict ：严格模式无法在不声明变量的情况下使用变量；不允许使用为未来预留的关键词 Let关键字1234567var x = 10;// 此处 x 为 10&#123; let x = 6;// 此处 x 为 6&#125;// 此处 x 为 10 在相同的作用域，或在相同的块中， 不允许用let 重新声明变量，let 变量也不允许被重新声明： 123456var x = 10; // 允许let x = 6; // 不允许&#123; var x = 10; // 允许 let x = 6; // 不允许&#125; Const关键字没有定义常量值。定义了对值的常量引用。因此，不能更改常量原始值，但可以更改常量对象的属性。在不同的作用域或块中重新声明 const 是允许的： JS调试console.log() 可在调试窗口中显示 JavaScript 的值debugger关键词会停止 JavaScript 的执行，并调用（如果有）调试函数。与在调试器中设置断点的功能是一样的。 Safari Develop Menu： 点击 Safari 菜单，偏好设置，高级 选中“在菜单栏中启用开发菜单” 当菜单中出现新选项“开发”时，选择“显示错误控制台” JS最佳实践请避免使用全局变量、new、===、eval() JS常见错误测试对象是否存在：if (typeof myObj !== “undefined” &amp;&amp; myObj !== null)JavaScript 不会为每个代码块创建新的作用域。 1234for (var i = 0; i &lt; 10; i++) &#123; // 代码块&#125;return i; //10 JS性能提升 减少循环中的活动 减少 DOM 访问 缩减 DOM 规模 避免不必要的变量 延迟 JavaScript 加载]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spike-github-blog]]></title>
    <url>%2F2019%2F08%2F14%2FSpike-github-blog-framework%2F</url>
    <content type="text"><![CDATA[三种方案：Jekyll VS Hexo VS HugoJekyll 官网: https://jekyllrb.com 使用语言: Ruby 支持的文件格式: html/md Pros: 把原文上传github，会自动帮你生成静态网站。 Github Pages天然支持Jekyll. 基于GitHub，安全性能较高 相对hexo而言，可以直接在github网页版上编辑和发布博客，PC间切换和同步非常方便。 Cons: 不支持在titles或者YAML使用变量. 不内置支持livereload 不内置支持post pagination Hexo官网：https://hexo.io/ 使用语言: NodeJS 支持的文件格式: md Pros: 快 操作简单，命令少，易于记忆 Cons: 使用主体为中国社区 更换电脑则需重新安装环境 本地生成 html 再上传GitHub，部署需：one deploy command Hugo官网：https://gohugo.io/使用语言: Golang支持的文件格式: md Pros： 最快 内置 dynamic API driven 内置 unlimited content types、i18n、multiple output format 预置模版 Cons： 支持的插件少、扩展性不够 吸引于Hexo的简洁操作，下面介绍基于hexo搭建博客的流程：1. 环境准备 Node.js (Should be at least nodejs 6.9） Git 2. Hello World2.1 Github上新建名为username.github.io的仓库并初始化2.2 安装Hexo1234npm install -g hexo-cli hexo inithexo g //生成hexo s //启动服务 2.3 在github.io仓库中创建index.html打开https://username.github.io/即可访问个人博客啦！ 3. 自定义主题hexo官网自带主题库：https://hexo.io/themes/或GitHub自行查找主题，此处选用GitHub最火之next 3.1 下载主题12cd your-hexo-sitegit clone https://github.com/theme-next/hexo-theme-next themes/next 3.2 启用主题将Hexo文件夹下_config.yml 内的 theme 字段修改为next 3.3 选择Scheme目前NexT支持三种Scheme Muse – 默认 Scheme，黑白主调，大量留白 Mist – Muse 的紧凑版本，整洁有序的单栏外观 Pisces – 双栏 Scheme 更改NexT文件夹下_config.yml文件，搜索scheme，将需要启用的 scheme 前面的注释 # 去除即可 3.4 设置语言更改NexT文件夹下_config.yml文件，搜索language，配置为：language: en 3.5 部署 修改_config.yml文件： 1234deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 安装 hexo-deployer-git：npm install hexo-deployer-git --save 生成站点文件并推送至远程库，执行hexo clean &amp;&amp; hexo deploy 启动服务器hexo s 至此，你的个人博客就搭建好啦！！！ 4. 参考文献https://www.techiediaries.com/jekyll-hugo-hexo/]]></content>
      <categories>
        <category>实习</category>
      </categories>
  </entry>
</search>
